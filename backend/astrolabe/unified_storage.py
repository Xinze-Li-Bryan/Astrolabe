"""
Unified Storage

Unified Node/Edge storage system:
- graph_data: Read-only data from graph.json (generated by Lean parsing)
- meta_path: Path to meta.json (user data, read/write)

API design principles:
- Lean node/edge identity information (name, kind, file_path, etc.) comes from graph_data and cannot be modified
- Lean node/edge style overrides (color, size, notes, etc.) are stored in meta.json
- User node/edge complete data is stored in meta.json
- Edge type: "reference" (Lean) or "custom" (User)
"""

import json
from pathlib import Path
from typing import Optional


class UnifiedStorage:
    """Unified Node/Edge storage manager"""

    def __init__(self, graph_data: dict, meta_path: Path):
        """
        Initialize storage manager

        Args:
            graph_data: Contents of graph.json (read-only, Lean parsing data)
            meta_path: Path to meta.json (read/write, user data)
        """
        self._graph_data = graph_data
        self._meta_path = meta_path
        self._meta = self._load_meta()

        # Build index of Lean nodes/edges for convenient querying
        self._lean_node_ids = {n["id"] for n in graph_data.get("nodes", [])}
        self._lean_edge_ids = {
            f"{e['source']}->{e['target']}" for e in graph_data.get("edges", [])
        }

        # Build dictionary index of Lean nodes for fast lookup
        self._lean_nodes_by_id = {n["id"]: n for n in graph_data.get("nodes", [])}
        self._lean_edges_by_id = {
            f"{e['source']}->{e['target']}": e for e in graph_data.get("edges", [])
        }

    def _load_meta(self) -> dict:
        """Load meta.json"""
        if self._meta_path.exists():
            return json.loads(self._meta_path.read_text(encoding="utf-8"))
        return {"nodes": {}, "edges": {}, "macros": {}}

    def _save_meta(self):
        """Save meta.json"""
        self._meta_path.parent.mkdir(parents=True, exist_ok=True)
        self._meta_path.write_text(
            json.dumps(self._meta, indent=2, ensure_ascii=False), encoding="utf-8"
        )

    # =========================================
    # Node operations (only modify meta.json)
    # =========================================

    def add_user_node(
        self,
        node_id: str,
        name: str,
        kind: str = "custom",
        references: list[str] = None,
        **kwargs,
    ) -> dict:
        """
        Add User node

        Args:
            node_id: Node ID (format: custom-xxx)
            name: Node name (required)
            kind: Node type (default: custom)
            references: Dependency list
            **kwargs: Other attributes (notes, color, etc.)

        Returns:
            Created node data

        Raises:
            ValueError: If name or kind is empty
        """
        if not name:
            raise ValueError("name is required for user node")
        if not kind:
            raise ValueError("kind is required for user node")

        node_data = {
            "name": name,
            "kind": kind,
            "references": references if references is not None else [],
        }

        # Add other optional attributes
        for key, value in kwargs.items():
            if value is not None:
                node_data[key] = value

        self._meta["nodes"][node_id] = node_data
        self._save_meta()

        return {"id": node_id, **node_data}

    # Identity fields of Lean nodes should not be stored in meta
    _LEAN_IDENTITY_FIELDS = {"name", "kind", "file_path", "line_number", "status", "content", "references", "depends_on_count", "used_by_count", "depth"}

    def _should_delete(self, value) -> bool:
        """Check if value indicates deletion (empty string or -1)"""
        if value == "" or value == -1:
            return True
        return False

    def update_node_meta(self, node_id: str, **kwargs) -> bool:
        """
        Update node meta attributes

        For Lean nodes: Only store style override attributes (color, size, notes, etc.)
        For User nodes: Can update all attributes (including name)

        Special values:
        - Empty string "" or -1 indicates deletion of that attribute

        Args:
            node_id: Node ID
            **kwargs: Attributes to update

        Returns:
            Whether successful
        """
        if node_id not in self._meta["nodes"]:
            self._meta["nodes"][node_id] = {}

        # For Lean nodes, filter out identity fields
        if self.is_lean_node(node_id):
            for key, value in kwargs.items():
                if key not in self._LEAN_IDENTITY_FIELDS:
                    if self._should_delete(value):
                        # Delete this attribute
                        self._meta["nodes"][node_id].pop(key, None)
                    elif value is not None:
                        self._meta["nodes"][node_id][key] = value
        else:
            # User nodes can update all fields
            for key, value in kwargs.items():
                if self._should_delete(value):
                    # Delete this attribute
                    self._meta["nodes"][node_id].pop(key, None)
                elif value is not None:
                    self._meta["nodes"][node_id][key] = value

        # If node meta becomes empty, delete entire node entry
        if not self._meta["nodes"][node_id]:
            del self._meta["nodes"][node_id]

        self._save_meta()
        return True

    def delete_node(self, node_id: str) -> bool:
        """
        Delete node

        For User nodes: Actually delete, and cascade delete related edges
        For Lean nodes: Only clear meta override attributes

        Args:
            node_id: Node ID

        Returns:
            Whether successful
        """
        if self.is_user_node(node_id):
            # User node: Actually delete
            if node_id in self._meta["nodes"]:
                del self._meta["nodes"][node_id]

            # Cascade delete related edges (edges where source or target is this node)
            edges_to_delete = []
            for edge_id, edge_data in self._meta.get("edges", {}).items():
                source = edge_data.get("source")
                target = edge_data.get("target")
                # If no source/target fields, parse from edge_id
                if source is None or target is None:
                    parts = edge_id.split("->")
                    if len(parts) == 2:
                        source, target = parts
                if source == node_id or target == node_id:
                    edges_to_delete.append(edge_id)

            for edge_id in edges_to_delete:
                del self._meta["edges"][edge_id]

            # Update references in other User nodes (remove references to this node)
            for other_node_id, other_node_data in self._meta.get("nodes", {}).items():
                if self.is_user_node(other_node_id):
                    refs = other_node_data.get("references", [])
                    if node_id in refs:
                        refs.remove(node_id)
        else:
            # Lean node: Only clear meta
            if node_id in self._meta["nodes"]:
                del self._meta["nodes"][node_id]

        self._save_meta()
        return True

    def get_node_meta(self, node_id: str) -> Optional[dict]:
        """
        Get node meta data (only returns the part stored in meta.json)

        Args:
            node_id: Node ID

        Returns:
            Meta data, or None if not found
        """
        return self._meta.get("nodes", {}).get(node_id)

    def get_all_user_nodes(self) -> list[dict]:
        """
        Get all custom nodes (starting with custom-)

        Returns:
            List of User nodes
        """
        result = []
        for node_id, node_data in self._meta.get("nodes", {}).items():
            if self.is_user_node(node_id):
                result.append({"id": node_id, **node_data})
        return result

    # =========================================
    # Edge operations (only modify meta.json)
    # =========================================

    def add_user_edge(
        self,
        source: str,
        target: str,
        **kwargs,
    ) -> dict:
        """
        Add User edge

        Also updates source node's references (if it's a User node)

        Args:
            source: Source node ID
            target: Target node ID
            **kwargs: Other attributes (notes, color, width, etc.)

        Returns:
            Created edge data (includes id, source, target, type="custom")
        """
        edge_id = f"{source}->{target}"

        edge_data = {
            "source": source,
            "target": target,
            "type": "custom",
        }

        # Add other optional attributes
        for key, value in kwargs.items():
            if value is not None:
                edge_data[key] = value

        self._meta["edges"][edge_id] = edge_data

        # If source is a User node, update its references
        if self.is_user_node(source) and source in self._meta.get("nodes", {}):
            refs = self._meta["nodes"][source].get("references", [])
            if target not in refs:
                refs.append(target)
                self._meta["nodes"][source]["references"] = refs

        self._save_meta()
        return {"id": edge_id, **edge_data}

    def update_edge_meta(self, edge_id: str, **kwargs) -> bool:
        """
        Update edge meta attributes

        Special values:
        - Empty string "" or -1 indicates deletion of that attribute

        Args:
            edge_id: Edge ID (format: source->target)
            **kwargs: Attributes to update (color, width, style, effect, notes)

        Returns:
            Whether successful
        """
        if edge_id not in self._meta["edges"]:
            self._meta["edges"][edge_id] = {}

        for key, value in kwargs.items():
            if self._should_delete(value):
                # Delete this attribute
                self._meta["edges"][edge_id].pop(key, None)
            elif value is not None:
                self._meta["edges"][edge_id][key] = value

        # If edge meta becomes empty (only source/target/type remaining), consider whether to keep
        # For custom edges, keep source/target/type
        # For Lean edges, delete entire entry if meta is empty
        edge_data = self._meta["edges"].get(edge_id, {})
        # Check if only basic fields remain
        meta_keys = set(edge_data.keys()) - {"source", "target", "type"}
        if not meta_keys and edge_id in self._lean_edge_ids:
            # Lean edge with no style overrides, delete entry
            del self._meta["edges"][edge_id]

        self._save_meta()
        return True

    def delete_edge(self, edge_id: str) -> bool:
        """
        Delete edge

        Can only delete User edges (type=custom), Lean edges cannot be deleted

        Also updates source node's references (if it's a User node)

        Args:
            edge_id: Edge ID

        Returns:
            Whether successful

        Raises:
            ValueError: If attempting to delete a Lean edge
        """
        # Check if it's a Lean edge (and not overridden to custom)
        if self.is_lean_edge(edge_id):
            edge_meta = self._meta.get("edges", {}).get(edge_id, {})
            if edge_meta.get("type") != "custom":
                raise ValueError("Cannot delete Lean edge")

        # Parse source and target
        parts = edge_id.split("->")
        if len(parts) == 2:
            source, target = parts

            # If source is a User node, update its references
            if self.is_user_node(source) and source in self._meta.get("nodes", {}):
                refs = self._meta["nodes"][source].get("references", [])
                if target in refs:
                    refs.remove(target)

        # Delete edge
        if edge_id in self._meta["edges"]:
            del self._meta["edges"][edge_id]

        self._save_meta()
        return True

    def get_edge_meta(self, edge_id: str) -> Optional[dict]:
        """
        Get edge meta data

        Args:
            edge_id: Edge ID

        Returns:
            Meta data, or None if not found
        """
        return self._meta.get("edges", {}).get(edge_id)

    def get_all_user_edges(self) -> list[dict]:
        """
        Get all User edges (type=custom)

        Returns:
            List of User edges
        """
        result = []
        for edge_id, edge_data in self._meta.get("edges", {}).items():
            if edge_data.get("type") == "custom":
                result.append({"id": edge_id, **edge_data})
        return result

    # =========================================
    # Merged queries (graph.json + meta.json)
    # =========================================

    def get_all_nodes(self) -> list[dict]:
        """
        Get all nodes (Lean + User, merged with meta)

        Returns:
            List of all merged nodes
        """
        result = []

        # Add Lean nodes (merged with meta)
        for lean_node in self._graph_data.get("nodes", []):
            node_id = lean_node["id"]
            merged = lean_node.copy()
            meta_data = self._meta.get("nodes", {}).get(node_id, {})
            merged.update(meta_data)
            result.append(merged)

        # Add User nodes
        for node_id, node_data in self._meta.get("nodes", {}).items():
            if self.is_user_node(node_id):
                result.append({"id": node_id, **node_data})

        return result

    def get_all_edges(self) -> list[dict]:
        """
        Get all edges (Lean + User, merged with meta)

        Returns:
            List of all merged edges
        """
        result = []

        # Add Lean edges (merged with meta)
        for lean_edge in self._graph_data.get("edges", []):
            edge_id = f"{lean_edge['source']}->{lean_edge['target']}"
            merged = {
                "id": edge_id,
                "source": lean_edge["source"],
                "target": lean_edge["target"],
                "type": "reference",  # Lean edges default to reference type
            }
            meta_data = self._meta.get("edges", {}).get(edge_id, {})
            merged.update(meta_data)
            result.append(merged)

        # Add User edges (not in Lean edge collection)
        for edge_id, edge_data in self._meta.get("edges", {}).items():
            if edge_id not in self._lean_edge_ids:
                result.append({"id": edge_id, **edge_data})

        return result

    def get_node(self, node_id: str) -> Optional[dict]:
        """
        Get a single node (merged from graph_data and meta)

        Args:
            node_id: Node ID

        Returns:
            Merged node data, or None if not found
        """
        # Check if it's a Lean node
        if node_id in self._lean_nodes_by_id:
            # Merge Lean data and meta
            lean_data = self._lean_nodes_by_id[node_id].copy()
            meta_data = self._meta.get("nodes", {}).get(node_id, {})
            lean_data.update(meta_data)
            return lean_data

        # Check if it's a User node
        if node_id in self._meta.get("nodes", {}):
            node_data = self._meta["nodes"][node_id].copy()
            return {"id": node_id, **node_data}

        return None

    def get_edge(self, edge_id: str) -> Optional[dict]:
        """
        Get a single edge (merged from graph_data and meta)

        Args:
            edge_id: Edge ID

        Returns:
            Merged edge data, or None if not found
        """
        # Check if it's a Lean edge
        if edge_id in self._lean_edges_by_id:
            lean_edge = self._lean_edges_by_id[edge_id]
            merged = {
                "id": edge_id,
                "source": lean_edge["source"],
                "target": lean_edge["target"],
                "type": "reference",  # Lean edges default to reference type
            }
            meta_data = self._meta.get("edges", {}).get(edge_id, {})
            merged.update(meta_data)
            return merged

        # Check if it's a User edge
        if edge_id in self._meta.get("edges", {}):
            edge_data = self._meta["edges"][edge_id].copy()
            return {"id": edge_id, **edge_data}

        return None

    # =========================================
    # Helper methods
    # =========================================

    def is_user_node(self, node_id: str) -> bool:
        """Check if it's a custom node (starts with custom-)"""
        return node_id.startswith("custom-")

    def is_lean_node(self, node_id: str) -> bool:
        """Check if it's a Lean node (exists in graph_data)"""
        return node_id in self._lean_node_ids

    def is_user_edge(self, edge_id: str) -> bool:
        """Check if it's a User edge (type=custom or not in Lean edge collection)"""
        # If not in Lean edge collection, definitely a User edge
        if edge_id not in self._lean_edge_ids:
            return True
        # If in Lean edge collection, check if marked as custom in meta
        meta = self._meta.get("edges", {}).get(edge_id, {})
        return meta.get("type") == "custom"

    def is_lean_edge(self, edge_id: str) -> bool:
        """Check if it's a Lean edge (exists in graph_data)"""
        return edge_id in self._lean_edge_ids

    # =========================================
    # Macros operations
    # =========================================

    def get_macros(self) -> dict[str, str]:
        """
        Get all macros

        Returns:
            Macros dictionary {name: definition}
        """
        return self._meta.get("macros", {}).copy()

    def set_macros(self, macros: dict[str, str]):
        """
        Set all macros (complete replacement)

        Args:
            macros: New macros dictionary
        """
        self._meta["macros"] = macros.copy()
        self._save_meta()

    def update_macros(self, updates: dict[str, str | None]):
        """
        Incrementally update macros

        Args:
            updates: Macros to update, None value indicates deletion
        """
        if "macros" not in self._meta:
            self._meta["macros"] = {}

        for key, value in updates.items():
            if value is None:
                # Delete
                self._meta["macros"].pop(key, None)
            else:
                # Update or add
                self._meta["macros"][key] = value

        self._save_meta()

    def clear(self):
        """
        Clear all meta data (nodes, edges, macros)

        Note: This does not affect graph_data (Lean parsing data)
        """
        self._meta = {"nodes": {}, "edges": {}, "macros": {}}
        self._save_meta()
